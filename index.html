<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="theme-color" content="#0a0a0a">
    <title>サーバー崩壊ラプソディ</title>
    <style>
        /* ===== リセット & 基本設定 ===== */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --color-bg: #0a0a0a;
            --color-primary: #00ff00;
            --color-secondary: #ff6600;
            --color-danger: #ff0040;
            --color-warning: #ffff00;
            --color-info: #00ffff;
            --color-muted: #404040;
            --color-white: #ffffff;
        }

        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: var(--color-bg);
            font-family: 'Courier New', Courier, monospace;
            color: var(--color-primary);
            user-select: none;
            -webkit-user-select: none;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
        }

        /* ===== ゲームコンテナ ===== */
        #game-container {
            width: 100%;
            height: 100%;
            max-width: 100vw;
            max-height: 100vh;
            margin: 0 auto;
            position: relative;
            overflow: hidden;
        }

        /* ===== 画面共通 ===== */
        .screen {
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            width: 100%;
            height: 100%;
            position: absolute;
            top: 0;
            left: 0;
            padding: 16px;
            padding-top: env(safe-area-inset-top, 16px);
            padding-bottom: env(safe-area-inset-bottom, 16px);
        }

        .screen.active {
            display: flex;
        }

        /* ===== タイトル画面 ===== */
        #title-screen {
            background: linear-gradient(180deg, #0a0a0a 0%, #1a0a1a 100%);
            gap: 24px;
        }

        #title-screen h1 {
            font-size: 24px;
            text-align: center;
            line-height: 1.6;
            letter-spacing: 2px;
            text-shadow: 
                3px 3px 0 var(--color-danger),
                -2px -2px 0 var(--color-info);
            animation: glitch 2s infinite;
        }

        .subtitle {
            font-size: 10px;
            color: var(--color-muted);
            letter-spacing: 1px;
        }

        .version {
            font-size: 10px;
            color: var(--color-muted);
            position: absolute;
            bottom: 20px;
        }

        @keyframes glitch {
            0%, 90%, 100% { transform: translate(0); }
            92% { transform: translate(-3px, 2px); }
            94% { transform: translate(3px, -2px); }
            96% { transform: translate(-2px, 3px); }
            98% { transform: translate(2px, -3px); }
        }

        /* ===== ボタン ===== */
        .pixel-btn {
            font-family: 'Courier New', Courier, monospace;
            font-size: 14px;
            font-weight: bold;
            padding: 16px 32px;
            background: var(--color-muted);
            color: var(--color-primary);
            border: 3px solid var(--color-primary);
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 1px;
            box-shadow: 4px 4px 0 var(--color-primary);
            transition: transform 0.1s, box-shadow 0.1s;
            -webkit-tap-highlight-color: transparent;
        }

        .pixel-btn:active {
            transform: translate(2px, 2px);
            box-shadow: 2px 2px 0 var(--color-primary);
            background: var(--color-primary);
            color: var(--color-bg);
        }

        /* ===== ゲーム画面 ===== */
        #game-screen {
            background: var(--color-bg);
            gap: 8px;
            justify-content: flex-start;
            padding-top: 8px;
        }

        /* ステータスバー */
        #status-bar {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 6px;
            width: 100%;
            padding: 8px;
            background: rgba(0, 255, 0, 0.05);
            border: 2px solid var(--color-primary);
            font-size: 10px;
        }

        .status-item {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }

        .status-item .label {
            color: var(--color-muted);
            font-size: 9px;
        }

        .status-item .value {
            color: var(--color-primary);
            font-size: 11px;
            font-weight: bold;
        }

        .mini-bar {
            width: 100%;
            height: 8px;
            background: var(--color-muted);
            border: 1px solid var(--color-primary);
        }

        .mini-bar-fill {
            height: 100%;
            width: 0%;
            background: var(--color-primary);
            transition: width 0.1s, background 0.1s;
        }

        .mini-bar-fill.warning { background: var(--color-warning); }
        .mini-bar-fill.danger { 
            background: var(--color-danger); 
            animation: blink 0.2s infinite;
        }

        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        /* サーバーエリア */
        #server-area {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            width: 100%;
            min-height: 200px;
            cursor: pointer;
            border: 2px dashed var(--color-muted);
            background: rgba(0, 255, 0, 0.02);
        }

        #server-canvas {
            image-rendering: pixelated;
            image-rendering: crisp-edges;
            max-width: 100%;
            max-height: 100%;
        }

        #tap-effect {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            overflow: hidden;
        }

        .tap-ripple {
            position: absolute;
            width: 60px;
            height: 60px;
            border: 4px solid var(--color-secondary);
            border-radius: 50%;
            animation: ripple 0.5s ease-out forwards;
            pointer-events: none;
        }

        @keyframes ripple {
            0% { transform: translate(-50%, -50%) scale(0); opacity: 1; }
            100% { transform: translate(-50%, -50%) scale(2); opacity: 0; }
        }

        /* タップ指示 */
        #tap-hint {
            position: absolute;
            bottom: 10px;
            font-size: 12px;
            color: var(--color-secondary);
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 0.5; }
            50% { opacity: 1; }
        }

        /* ログエリア */
        #log-area {
            width: 100%;
            height: 100px;
            background: #050505;
            border: 2px solid var(--color-primary);
            padding: 6px;
            overflow: hidden;
            font-size: 9px;
            line-height: 1.4;
        }

        #log-content {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }

        .log-line {
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            animation: typeIn 0.1s ease-out;
        }

        .log-line.error { color: var(--color-danger); }
        .log-line.warning { color: var(--color-warning); }
        .log-line.info { color: var(--color-info); }

        @keyframes typeIn {
            from { opacity: 0; transform: translateX(-10px); }
            to { opacity: 1; transform: translateX(0); }
        }

        /* タップカウント */
        #tap-count {
            font-size: 14px;
            font-weight: bold;
            color: var(--color-secondary);
            padding: 10px;
            background: rgba(255, 102, 0, 0.1);
            border: 2px solid var(--color-secondary);
            width: 100%;
            text-align: center;
        }

        /* ===== 崩壊画面 ===== */
        #crash-screen {
            background: var(--color-bg);
        }

        #crash-effect {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        #crash-content {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 16px;
            z-index: 10;
            width: 100%;
            max-width: 320px;
        }

        #crash-title {
            font-size: 18px;
            color: var(--color-danger);
            text-align: center;
            animation: shake 0.5s ease-in-out;
        }

        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            20%, 60% { transform: translateX(-5px); }
            40%, 80% { transform: translateX(5px); }
        }

        #crash-log {
            font-size: 9px;
            color: var(--color-danger);
            background: rgba(255, 0, 64, 0.1);
            border: 2px solid var(--color-danger);
            padding: 12px;
            width: 100%;
            max-height: 120px;
            overflow-y: auto;
            white-space: pre-wrap;
            word-break: break-all;
        }

        #score-display {
            display: flex;
            flex-direction: column;
            gap: 8px;
            width: 100%;
        }

        .score-item {
            display: flex;
            justify-content: space-between;
            padding: 8px 12px;
            background: rgba(0, 255, 0, 0.05);
            border: 1px solid var(--color-primary);
        }

        .score-label { font-size: 10px; color: var(--color-muted); }
        .score-value { font-size: 12px; color: var(--color-primary); font-weight: bold; }

        /* ===== BSOD画面 ===== */
        #bsod-screen {
            background: #0078d7;
            color: var(--color-white);
        }

        .bsod-content {
            padding: 24px;
            text-align: left;
            max-width: 100%;
        }

        .bsod-sad { font-size: 60px; margin-bottom: 16px; }
        .bsod-text { font-size: 11px; line-height: 1.6; margin-bottom: 16px; }
        .bsod-error { font-size: 9px; margin-bottom: 8px; opacity: 0.8; }
        .bsod-percent { font-size: 11px; margin-bottom: 24px; }

        .bsod-btn {
            border-color: var(--color-white);
            color: var(--color-white);
            box-shadow: 4px 4px 0 var(--color-white);
        }

        .bsod-btn:active {
            background: var(--color-white);
            color: #0078d7;
        }

        /* ===== エフェクト ===== */
        .explosion-particle {
            position: fixed;
            pointer-events: none;
        }

        .scatter-pixel {
            position: fixed;
            pointer-events: none;
        }

        .freeze-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: repeating-linear-gradient(
                0deg, transparent, transparent 2px,
                rgba(255, 255, 255, 0.05) 2px, rgba(255, 255, 255, 0.05) 4px
            );
            pointer-events: none;
            animation: scanline 0.1s linear infinite;
        }

        @keyframes scanline {
            from { transform: translateY(0); }
            to { transform: translateY(4px); }
        }

        .screen-shake {
            animation: screenShake 0.3s ease-in-out;
        }

        @keyframes screenShake {
            0%, 100% { transform: translate(0, 0); }
            20% { transform: translate(-4px, -4px); }
            40% { transform: translate(4px, 4px); }
            60% { transform: translate(-4px, 4px); }
            80% { transform: translate(4px, -4px); }
        }

        /* CRTエフェクト（軽量版） */
        #game-container::after {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: repeating-linear-gradient(
                0deg, transparent, transparent 2px,
                rgba(0, 0, 0, 0.1) 2px, rgba(0, 0, 0, 0.1) 4px
            );
            pointer-events: none;
            z-index: 1000;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <!-- タイトル画面 -->
        <div id="title-screen" class="screen active">
            <h1>サーバー崩壊<br>ラプソディ</h1>
            <p class="subtitle">~ Server Crash Rhapsody ~</p>
            <button id="start-btn" class="pixel-btn">TAP TO START</button>
            <p class="version">v1.0.0</p>
        </div>

        <!-- ゲーム画面 -->
        <div id="game-screen" class="screen">
            <div id="status-bar">
                <div class="status-item">
                    <span class="label">CPU:</span>
                    <span id="cpu-value" class="value">0%</span>
                    <div class="mini-bar"><div id="cpu-bar" class="mini-bar-fill"></div></div>
                </div>
                <div class="status-item">
                    <span class="label">MEM:</span>
                    <span id="mem-value" class="value">0MB</span>
                    <div class="mini-bar"><div id="mem-bar" class="mini-bar-fill"></div></div>
                </div>
                <div class="status-item">
                    <span class="label">NET:</span>
                    <span id="net-value" class="value">0ms</span>
                    <div class="mini-bar"><div id="net-bar" class="mini-bar-fill"></div></div>
                </div>
                <div class="status-item">
                    <span class="label">DISK:</span>
                    <span id="disk-value" class="value">OK</span>
                    <div class="mini-bar"><div id="disk-bar" class="mini-bar-fill"></div></div>
                </div>
            </div>

            <div id="server-area">
                <canvas id="server-canvas" width="160" height="220"></canvas>
                <div id="tap-effect"></div>
                <div id="tap-hint">[ TAP SERVER ]</div>
            </div>

            <div id="log-area">
                <div id="log-content"></div>
            </div>

            <div id="tap-count">
                <span>LOAD: </span><span id="load-count">0</span>
            </div>
        </div>

        <!-- 崩壊画面 -->
        <div id="crash-screen" class="screen">
            <div id="crash-effect"></div>
            <div id="crash-content">
                <h2 id="crash-title">SYSTEM FAILURE</h2>
                <div id="crash-log"></div>
                <div id="score-display">
                    <div class="score-item">
                        <span class="score-label">耐久時間</span>
                        <span id="time-score" class="score-value">0.0s</span>
                    </div>
                    <div class="score-item">
                        <span class="score-label">崩壊指標</span>
                        <span id="crash-indicators" class="score-value">0</span>
                    </div>
                    <div class="score-item">
                        <span class="score-label">芸術点</span>
                        <span id="art-score" class="score-value">???</span>
                    </div>
                </div>
                <button id="restart-btn" class="pixel-btn">REBOOT</button>
            </div>
        </div>

        <!-- BSOD画面 -->
        <div id="bsod-screen" class="screen">
            <div class="bsod-content">
                <p class="bsod-sad">:(</p>
                <p class="bsod-text">Your server ran into a problem and needs to restart.</p>
                <p class="bsod-error" id="bsod-error"></p>
                <p class="bsod-percent" id="bsod-percent">0% complete</p>
                <button id="bsod-restart-btn" class="pixel-btn bsod-btn">REBOOT</button>
            </div>
        </div>
    </div>

<script>
/**
 * サーバー崩壊ラプソディ v1.0
 * GitHub Pages + スマホ最適化版
 */

// ===== ランダム生成 =====
const R = {
    random: () => Math.random(),
    int: (min, max) => Math.floor(Math.random() * (max - min + 1)) + min,
    float: (min, max) => Math.random() * (max - min) + min,
    pick: (arr) => arr[Math.floor(Math.random() * arr.length)],
    chance: (pct) => Math.random() * 100 < pct,
    pickMultiple: (arr, n) => [...arr].sort(() => Math.random() - 0.5).slice(0, n)
};

// ===== ログメッセージ =====
const LOGS = {
    normal: [
        '[INFO] Server running...',
        '[DEBUG] Heartbeat OK',
        '[INFO] Request processed',
        '[DEBUG] Cache hit',
        '[INFO] Connection OK'
    ],
    warning: [
        '[WARN] High CPU usage',
        '[WARN] Memory pressure',
        '[WARN] Slow query',
        '[WARN] Pool exhausted',
        '[WARN] なんかヤバい'
    ],
    error: [
        '[ERROR] Segfault',
        '[ERROR] OOM',
        '[ERROR] Timeout',
        '[ERROR] Stack overflow',
        '[FATAL] Kernel panic',
        '[ERROR] It works on my machine',
        '[ERROR] 想定外の想定外',
        '[PANIC] 誰かー！！'
    ],
    crash: [
        'KERNEL PANIC - VFS error',
        'Fatal exception',
        'BUG: NULL pointer',
        '*** STOP: 0x0000007E',
        'Guru Meditation',
        'PC LOAD LETTER',
        '原因: たぶん宇宙線',
        '犯人: 金曜デプロイ'
    ]
};

// ===== 崩壊タイプ =====
const CRASH_TYPES = ['explosion', 'freeze', 'scatter', 'bsod', 'silent', 'glitch'];

// ===== サウンド =====
class Sound {
    constructor() {
        this.ctx = null;
        this.ok = true;
    }
    
    init() {
        try {
            this.ctx = new (window.AudioContext || window.webkitAudioContext)();
        } catch(e) { this.ok = false; }
    }
    
    resume() {
        if (this.ctx?.state === 'suspended') this.ctx.resume();
    }
    
    beep(freq = 440, dur = 0.1, type = 'square') {
        if (!this.ok || !this.ctx) return;
        const o = this.ctx.createOscillator();
        const g = this.ctx.createGain();
        o.connect(g);
        g.connect(this.ctx.destination);
        o.frequency.value = freq;
        o.type = type;
        g.gain.setValueAtTime(0.3, this.ctx.currentTime);
        g.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + dur);
        o.start();
        o.stop(this.ctx.currentTime + dur);
    }
    
    tap() { this.beep(330, 0.05, 'square'); }
    warn() {
        if (this.warnCooldown) return;
        this.warnCooldown = true;
        this.beep(400, 0.15);
        setTimeout(() => this.beep(500, 0.15), 150);
        setTimeout(() => { this.warnCooldown = false; }, 1000);
    }
    
    explode() {
        if (!this.ok || !this.ctx) return;
        const o = this.ctx.createOscillator();
        const g = this.ctx.createGain();
        o.connect(g);
        g.connect(this.ctx.destination);
        o.type = 'sawtooth';
        o.frequency.setValueAtTime(150, this.ctx.currentTime);
        o.frequency.exponentialRampToValueAtTime(20, this.ctx.currentTime + 0.4);
        g.gain.setValueAtTime(0.4, this.ctx.currentTime);
        g.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.4);
        o.start();
        o.stop(this.ctx.currentTime + 0.4);
    }
    
    noise(dur = 0.3) {
        if (!this.ok || !this.ctx) return;
        const buf = this.ctx.createBuffer(1, this.ctx.sampleRate * dur, this.ctx.sampleRate);
        const d = buf.getChannelData(0);
        for (let i = 0; i < d.length; i++) d[i] = Math.random() * 2 - 1;
        const s = this.ctx.createBufferSource();
        const g = this.ctx.createGain();
        s.buffer = buf;
        s.connect(g);
        g.connect(this.ctx.destination);
        g.gain.setValueAtTime(0.2, this.ctx.currentTime);
        g.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + dur);
        s.start();
    }
}

// ===== サーバー描画 =====
class Server {
    constructor(canvas) {
        this.canvas = canvas;
        this.ctx = canvas.getContext('2d');
        this.w = canvas.width;
        this.h = canvas.height;
        this.frame = 0;
        this.stress = 0;
        this.leds = [true, true, true];
        this.smoke = [];
    }
    
    draw() {
        const ctx = this.ctx;
        const sw = 100, sh = 160;
        const sx = (this.w - sw) / 2, sy = 30;
        
        // 本体
        ctx.fillStyle = '#2a2a2a';
        ctx.fillRect(sx, sy, sw, sh);
        
        // フレーム
        ctx.fillStyle = '#1a1a1a';
        ctx.fillRect(sx, sy, sw, 6);
        ctx.fillRect(sx, sy + sh - 6, sw, 6);
        ctx.fillRect(sx, sy, 6, sh);
        ctx.fillRect(sx + sw - 6, sy, 6, sh);
        
        // ユニット
        for (let i = 0; i < 3; i++) {
            const uy = sy + 14 + i * 48;
            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(sx + 10, uy, sw - 20, 40);
            
            // 通気孔
            const hc = this.stress > 70 ? '#ff3300' : this.stress > 40 ? '#ffaa00' : '#333';
            ctx.fillStyle = hc;
            for (let j = 0; j < 6; j++) {
                for (let k = 0; k < 2; k++) {
                    if ((j + k + this.frame) % 3 !== 0 || this.stress < 30)
                        ctx.fillRect(sx + 16 + j * 12, uy + 8 + k * 14, 8, 10);
                }
            }
            
            // LED
            if (this.frame % R.int(5, 15) === 0)
                this.leds[i] = R.chance(this.stress > 50 ? 30 : 90);
            
            const lc = this.stress > 80 ? '#ff0000' : this.stress > 50 ? '#ffaa00' : '#00ff00';
            ctx.fillStyle = this.leds[i] ? lc : '#333';
            ctx.fillRect(sx + sw - 22, uy + 8, 8, 8);
            
            // HDD LED
            ctx.fillStyle = R.chance(this.stress + 20) ? '#ff6600' : '#333';
            ctx.fillRect(sx + sw - 22, uy + 20, 8, 4);
        }
        
        // ケーブル
        ctx.fillStyle = '#0066ff';
        ctx.fillRect(sx + sw - 2, sy + 80, 10, 4);
        ctx.fillStyle = '#00ff00';
        ctx.fillRect(sx + sw - 2, sy + 88, 14, 4);
    }
    
    drawEffects() {
        const ctx = this.ctx;
        
        // 煙
        if (this.stress > 60 && R.chance(this.stress - 50)) {
            this.smoke.push({
                x: this.w/2 + R.int(-30, 30), y: 30,
                vx: R.float(-0.3, 0.3), vy: R.float(-1, -1.5),
                life: R.int(15, 30), size: R.int(4, 10)
            });
        }
        
        this.smoke = this.smoke.filter(p => {
            p.x += p.vx; p.y += p.vy; p.life--;
            if (p.life > 0) {
                ctx.fillStyle = `rgba(80,80,80,${p.life/30})`;
                ctx.fillRect(p.x, p.y, p.size, p.size);
                return true;
            }
            return false;
        });
        
        // シェイク
        if (this.stress > 80) {
            ctx.translate(R.int(-2, 2), R.int(-2, 2));
        }
        
        // グリッチライン
        if (this.stress > 70 && R.chance(25)) {
            ctx.fillStyle = R.pick(['#ff0000', '#00ff00', '#0000ff']);
            ctx.globalAlpha = 0.4;
            ctx.fillRect(0, R.int(0, this.h), this.w, R.int(2, 6));
            ctx.globalAlpha = 1;
        }
    }
    
    render(stress) {
        this.stress = stress;
        this.frame++;
        this.ctx.save();
        this.ctx.fillStyle = '#0a0a0a';
        this.ctx.fillRect(0, 0, this.w, this.h);
        this.drawEffects();
        this.draw();
        this.ctx.restore();
    }
    
    getPixels() { return this.ctx.getImageData(0, 0, this.w, this.h); }
    clear() { 
        this.ctx.fillStyle = '#0a0a0a';
        this.ctx.fillRect(0, 0, this.w, this.h);
        this.smoke = [];
    }
}

// ===== メインゲーム =====
class Game {
    constructor() {
        this.screens = {
            title: document.getElementById('title-screen'),
            game: document.getElementById('game-screen'),
            crash: document.getElementById('crash-screen'),
            bsod: document.getElementById('bsod-screen')
        };
        
        this.el = {
            startBtn: document.getElementById('start-btn'),
            restartBtn: document.getElementById('restart-btn'),
            bsodRestartBtn: document.getElementById('bsod-restart-btn'),
            canvas: document.getElementById('server-canvas'),
            serverArea: document.getElementById('server-area'),
            tapEffect: document.getElementById('tap-effect'),
            logContent: document.getElementById('log-content'),
            loadCount: document.getElementById('load-count'),
            cpuVal: document.getElementById('cpu-value'),
            memVal: document.getElementById('mem-value'),
            netVal: document.getElementById('net-value'),
            diskVal: document.getElementById('disk-value'),
            cpuBar: document.getElementById('cpu-bar'),
            memBar: document.getElementById('mem-bar'),
            netBar: document.getElementById('net-bar'),
            diskBar: document.getElementById('disk-bar'),
            crashTitle: document.getElementById('crash-title'),
            crashLog: document.getElementById('crash-log'),
            timeScore: document.getElementById('time-score'),
            crashIndicators: document.getElementById('crash-indicators'),
            artScore: document.getElementById('art-score'),
            bsodError: document.getElementById('bsod-error'),
            bsodPercent: document.getElementById('bsod-percent')
        };
        
        this.state = null;
        this.sound = new Sound();
        this.server = new Server(this.el.canvas);
        this.score = {};
        this.logTimer = 0;
        this.lastTime = 0;
        
        this.setupEvents();
    }
    
    setupEvents() {
        const tap = (el, fn) => {
            let touched = false;
            el.addEventListener('touchstart', e => {
                e.preventDefault(); touched = true; fn(e.touches[0]);
            }, {passive: false});
            el.addEventListener('click', e => {
                if (!touched) fn(e); touched = false;
            });
        };
        
        tap(this.el.startBtn, () => this.start());
        tap(this.el.restartBtn, () => this.restart());
        tap(this.el.bsodRestartBtn, () => this.restart());
        tap(this.el.serverArea, e => this.onTap(e));
    }
    
    showScreen(name) {
        Object.values(this.screens).forEach(s => s.classList.remove('active'));
        this.screens[name].classList.add('active');
    }
    
    start() {
        this.sound.init();
        this.sound.resume();
        
        this.state = {
            cpu: R.int(5, 15),
            mem: R.int(128, 512),
            net: R.int(1, 20),
            disk: R.int(5, 15),
            taps: 0,
            startTime: Date.now(),
            running: true,
            threshold: {
                cpu: R.int(150, 300),
                mem: R.int(16000, 32000),
                net: R.int(2000, 5000),
                disk: R.int(80, 100)
            },
            suddenDeath: R.int(50, 200),
            mysteryCrash: R.int(30, 120)
        };
        
        this.el.logContent.innerHTML = '';
        this.el.loadCount.textContent = '0';
        this.server.clear();
        
        this.showScreen('game');
        this.log('info', '[BOOT] System starting...');
        this.log('info', '[INIT] Server online');
        
        this.lastTime = performance.now();
        this.loop();
    }
    
    onTap(e) {
        if (!this.state?.running) return;
        
        this.sound.resume();
        this.sound.tap();
        
        const inc = {
            cpu: R.float(5, 25),
            mem: R.int(64, 512),
            net: R.int(10, 200),
            disk: R.float(0.5, 3)
        };
        
        this.state.cpu += inc.cpu;
        this.state.mem += inc.mem;
        this.state.net += inc.net;
        this.state.disk += inc.disk;
        this.state.taps++;
        
        this.el.loadCount.textContent = this.state.taps;
        this.ripple(e);
        
        if (R.chance(30)) this.randomLog();
        
        if (this.state.taps >= this.state.suddenDeath && R.chance(10)) {
            this.log('error', '[FATAL] SUDDEN DEATH');
            this.crash('突然死');
        }
    }
    
    ripple(e) {
        const rect = this.el.serverArea.getBoundingClientRect();
        let x = (e.clientX ?? e.pageX ?? rect.left + rect.width / 2) - rect.left;
        let y = (e.clientY ?? e.pageY ?? rect.top + rect.height / 2) - rect.top;
        x = Math.max(0, Math.min(x, rect.width));
        y = Math.max(0, Math.min(y, rect.height));
        
        const r = document.createElement('div');
        r.className = 'tap-ripple';
        r.style.left = x + 'px';
        r.style.top = y + 'px';
        r.style.borderColor = R.pick(['#ff6600', '#00ff00', '#ff0040', '#00ffff']);
        this.el.tapEffect.appendChild(r);
        setTimeout(() => r.remove(), 500);
    }
    
    log(type, msg) {
        const line = document.createElement('div');
        line.className = 'log-line ' + type;
        line.textContent = msg;
        this.el.logContent.appendChild(line);
        while (this.el.logContent.children.length > 6)
            this.el.logContent.removeChild(this.el.logContent.firstChild);
    }
    
    randomLog() {
        const stress = this.stress();
        let type, msgs;
        if (stress > 70) {
            type = R.chance(60) ? 'error' : 'warning';
            msgs = type === 'error' ? LOGS.error : LOGS.warning;
        } else if (stress > 40) {
            type = R.chance(40) ? 'warning' : 'info';
            msgs = type === 'warning' ? LOGS.warning : LOGS.normal;
        } else {
            type = 'info';
            msgs = LOGS.normal;
        }
        this.log(type, R.pick(msgs));
    }
    
    stress() {
        const t = this.state.threshold;
        return Math.max(
            this.state.cpu / t.cpu * 100,
            this.state.mem / t.mem * 100,
            this.state.net / t.net * 100,
            this.state.disk / t.disk * 100
        );
    }
    
    updateUI() {
        const t = this.state.threshold;
        const s = this.state;
        
        this.el.cpuVal.textContent = Math.floor(s.cpu) + '%';
        const cpuPct = Math.min(100, s.cpu / t.cpu * 100);
        this.el.cpuBar.style.width = cpuPct + '%';
        this.setBarClass(this.el.cpuBar, cpuPct);
        
        const memDisp = s.mem >= 1024 ? (s.mem/1024).toFixed(1) + 'GB' : Math.floor(s.mem) + 'MB';
        this.el.memVal.textContent = memDisp;
        const memPct = Math.min(100, s.mem / t.mem * 100);
        this.el.memBar.style.width = memPct + '%';
        this.setBarClass(this.el.memBar, memPct);
        
        this.el.netVal.textContent = Math.floor(s.net) + 'ms';
        const netPct = Math.min(100, s.net / t.net * 100);
        this.el.netBar.style.width = netPct + '%';
        this.setBarClass(this.el.netBar, netPct);
        
        const diskStates = ['OK', 'BUSY', 'SLOW', 'CRIT', '???'];
        this.el.diskVal.textContent = diskStates[Math.min(4, Math.floor(s.disk / 25))];
        const diskPct = Math.min(100, s.disk / t.disk * 100);
        this.el.diskBar.style.width = diskPct + '%';
        this.setBarClass(this.el.diskBar, diskPct);
    }
    
    setBarClass(bar, pct) {
        bar.classList.remove('warning', 'danger');
        if (pct > 80) bar.classList.add('danger');
        else if (pct > 50) bar.classList.add('warning');
    }
    
    checkCrash() {
        const t = this.state.threshold;
        const s = this.state;
        const elapsed = (Date.now() - s.startTime) / 1000;
        
        if (s.cpu >= t.cpu && s.mem >= t.mem) return this.crash('CPU+MEM超過');
        if (s.cpu >= t.cpu * 1.2) return this.crash('CPU暴走');
        if (s.mem >= t.mem * 1.1) return this.crash('OOM Killer');
        if (s.net >= t.net) return this.crash('ネットワーク断');
        if (s.disk >= t.disk) return this.crash('ディスク枯渇');
        if (elapsed >= s.mysteryCrash && R.chance(2)) return this.crash('なぜか今落ちた');
    }
    
    crash(reason) {
        this.state.running = false;
        
        const elapsed = (Date.now() - this.state.startTime) / 1000;
        const t = this.state.threshold;
        let indicators = 0;
        if (this.state.cpu >= t.cpu * 0.8) indicators++;
        if (this.state.mem >= t.mem * 0.8) indicators++;
        if (this.state.net >= t.net * 0.8) indicators++;
        if (this.state.disk >= t.disk * 0.8) indicators++;
        
        const arts = ['神', '芸術', '美', '良', '普通', '微妙', '???', '∞', 'NaN', 'エモい', '草'];
        this.score = { time: elapsed.toFixed(1), indicators, art: R.pick(arts), reason };
        
        const type = R.pick(CRASH_TYPES);
        this['crash_' + type]();
    }
    
    crash_explosion() {
        this.sound.explode();
        const container = document.getElementById('game-container');
        container.classList.add('screen-shake');
        
        for (let i = 0; i < R.int(20, 40); i++) {
            const p = document.createElement('div');
            p.className = 'explosion-particle';
            p.style.left = '50%';
            p.style.top = '40%';
            p.style.width = R.int(4, 12) + 'px';
            p.style.height = R.int(4, 12) + 'px';
            p.style.background = R.pick(['#ff6600', '#ff0040', '#ffff00', '#00ff00']);
            document.body.appendChild(p);
            
            const angle = R.float(0, Math.PI * 2);
            const vel = R.float(3, 15);
            let frame = 0;
            const animate = () => {
                frame++;
                const x = window.innerWidth/2 + Math.cos(angle) * vel * frame;
                const y = window.innerHeight * 0.4 + Math.sin(angle) * vel * frame + frame * 0.5;
                p.style.left = x + 'px';
                p.style.top = y + 'px';
                p.style.opacity = 1 - frame / 25;
                if (frame < 25) requestAnimationFrame(animate);
                else p.remove();
            };
            requestAnimationFrame(animate);
        }
        
        setTimeout(() => { container.classList.remove('screen-shake'); this.showCrashScreen(); }, 500);
    }
    
    crash_freeze() {
        if (R.chance(30)) this.sound.noise(0.2);
        const overlay = document.createElement('div');
        overlay.className = 'freeze-overlay';
        this.screens.game.appendChild(overlay);
        setTimeout(() => { overlay.remove(); this.showCrashScreen(); }, R.int(1500, 3000));
    }
    
    crash_scatter() {
        this.sound.noise(0.3);
        const pixels = this.server.getPixels();
        this.server.clear();
        const rect = this.el.canvas.getBoundingClientRect();
        const ps = 6;
        
        for (let y = 0; y < this.el.canvas.height; y += ps) {
            for (let x = 0; x < this.el.canvas.width; x += ps) {
                const i = (y * this.el.canvas.width + x) * 4;
                const r = pixels.data[i], g = pixels.data[i+1], b = pixels.data[i+2], a = pixels.data[i+3];
                if (a > 50 && (r > 20 || g > 20 || b > 20)) {
                    const p = document.createElement('div');
                    p.className = 'scatter-pixel';
                    p.style.left = (rect.left + x) + 'px';
                    p.style.top = (rect.top + y) + 'px';
                    p.style.width = ps + 'px';
                    p.style.height = ps + 'px';
                    p.style.background = `rgb(${r},${g},${b})`;
                    document.body.appendChild(p);
                    
                    const vx = R.float(-4, 4), vy = R.float(-8, 4);
                    let frame = 0;
                    const animate = () => {
                        frame++;
                        p.style.left = (parseFloat(p.style.left) + vx) + 'px';
                        p.style.top = (parseFloat(p.style.top) + vy + frame * 0.6) + 'px';
                        p.style.opacity = 1 - frame / 40;
                        if (frame < 40) requestAnimationFrame(animate);
                        else p.remove();
                    };
                    setTimeout(() => requestAnimationFrame(animate), R.int(0, 150));
                }
            }
        }
        setTimeout(() => this.showCrashScreen(), 1200);
    }
    
    crash_bsod() {
        this.sound.beep(800, 0.5);
        const errors = ['IRQL_NOT_LESS_OR_EQUAL', 'PAGE_FAULT', 'KERNEL_DATA_INPAGE_ERROR', 'CRITICAL_PROCESS_DIED'];
        this.el.bsodError.textContent = 'Stop code: ' + R.pick(errors);
        this.showScreen('bsod');
        
        let pct = 0;
        const target = R.int(0, 100);
        const iv = setInterval(() => {
            pct += R.int(1, 5);
            if (pct >= target) { pct = target; clearInterval(iv); }
            this.el.bsodPercent.textContent = pct + '% complete';
        }, R.int(100, 400));
    }
    
    crash_silent() {
        this.el.canvas.style.transition = 'opacity 0.5s';
        this.el.canvas.style.opacity = '0';
        setTimeout(() => {
            this.el.canvas.style.transition = '';
            this.el.canvas.style.opacity = '1';
            this.showCrashScreen();
        }, 1000);
    }
    
    crash_glitch() {
        this.sound.noise(0.4);
        const container = document.getElementById('game-container');
        let count = 0;
        const max = R.int(5, 12);
        const iv = setInterval(() => {
            count++;
            container.style.filter = R.pick(['hue-rotate(90deg)', 'invert(1)', 'saturate(5)', 'contrast(2)', '']);
            container.style.transform = `translate(${R.int(-8, 8)}px, ${R.int(-8, 8)}px)`;
            if (count >= max) {
                clearInterval(iv);
                container.style.filter = '';
                container.style.transform = '';
                this.showCrashScreen();
            }
        }, R.int(50, 120));
    }
    
    showCrashScreen() {
        const titles = ['SYSTEM FAILURE', 'FATAL ERROR', 'KERNEL PANIC', '壊れました', 'ご臨終です', 'F', '(´・ω・`)'];
        this.el.crashTitle.textContent = R.pick(titles);
        this.el.crashLog.textContent = R.pickMultiple(LOGS.crash, R.int(2, 4)).join('\n\n');
        this.el.timeScore.textContent = this.score.time + 's';
        this.el.crashIndicators.textContent = this.score.indicators + '/4';
        this.el.artScore.textContent = this.score.art;
        this.showScreen('crash');
    }
    
    restart() {
        document.querySelectorAll('.explosion-particle, .scatter-pixel').forEach(e => e.remove());
        this.start();
    }
    
    loop(now = 0) {
        if (!this.state?.running) return;
        
        const dt = (now - this.lastTime) / 1000;
        this.lastTime = now;
        
        // 減衰
        const decay = { cpu: R.float(0.5, 2), mem: R.int(8, 32), net: R.int(5, 20), disk: R.float(0.1, 0.5) };
        this.state.cpu = Math.max(0, this.state.cpu - decay.cpu * dt);
        this.state.mem = Math.max(0, this.state.mem - decay.mem * dt);
        this.state.net = Math.max(0, this.state.net - decay.net * dt);
        this.state.disk = Math.max(0, this.state.disk - decay.disk * dt);
        
        this.updateUI();
        this.server.render(this.stress());
        
        this.logTimer += dt;
        if (this.logTimer > R.float(2, 5)) {
            this.logTimer = 0;
            this.randomLog();
        }
        
        if (this.stress() > 80 && R.chance(5)) this.sound.warn();
        
        this.checkCrash();
        requestAnimationFrame(t => this.loop(t));
    }
}

// 起動
document.addEventListener('DOMContentLoaded', () => { window.game = new Game(); });
if (document.readyState !== 'loading') { window.game = window.game || new Game(); }
</script>
</body>
</html>
